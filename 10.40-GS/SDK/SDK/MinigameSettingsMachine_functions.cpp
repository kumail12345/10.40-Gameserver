#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MinigameSettingsMachine

#include "Basic.hpp"

#include "MinigameSettingsMachine_classes.hpp"
#include "MinigameSettingsMachine_parameters.hpp"


namespace SDK
{

// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateClassSettings
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateClassSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateClassSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.GetUIExtensions
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            Return_Value                                           (Parm, OutParm)

void AMinigameSettingsMachine_C::GetUIExtensions(struct FGameplayTagContainer* Return_Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "GetUIExtensions");

	Params::MinigameSettingsMachine_C_GetUIExtensions Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return_Value != nullptr)
		*Return_Value = std::move(Parms.Return_Value);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.Game Mode Preset Upgrade Path
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::Game_Mode_Preset_Upgrade_Path()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "Game Mode Preset Upgrade Path");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.GetScoreboardStatsArray
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UClass*>                   ScoreboardStats                                        (Parm, OutParm, ZeroConstructor)

void AMinigameSettingsMachine_C::GetScoreboardStatsArray(TArray<class UClass*>* ScoreboardStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "GetScoreboardStatsArray");

	Params::MinigameSettingsMachine_C_GetScoreboardStatsArray Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ScoreboardStats != nullptr)
		*ScoreboardStats = std::move(Parms.ScoreboardStats);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.FillTrackedStats
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::FillTrackedStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "FillTrackedStats");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.ToggleScriptedGameRules
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsScriptedGame                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMinigameSettingsMachine_C::ToggleScriptedGameRules(bool bIsScriptedGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "ToggleScriptedGameRules");

	Params::MinigameSettingsMachine_C_ToggleScriptedGameRules Parms{};

	Parms.bIsScriptedGame = bIsScriptedGame;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.TryAddEndCondition_DestroyObjects
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FFortMinigameStatQuery>   EndConditions                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMinigameSettingsMachine_C::TryAddEndCondition_DestroyObjects(TArray<struct FFortMinigameStatQuery>& EndConditions, bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "TryAddEndCondition_DestroyObjects");

	Params::MinigameSettingsMachine_C_TryAddEndCondition_DestroyObjects Parms{};

	Parms.EndConditions = std::move(EndConditions);

	UObject::ProcessEvent(Func, &Parms);

	EndConditions = std::move(Parms.EndConditions);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateTotalRounds
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateTotalRounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateTotalRounds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateMinigameMutators
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateMinigameMutators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateMinigameMutators");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateJoinInProgress
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateJoinInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateJoinInProgress");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.TryAddEndCondition_CollectItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FFortMinigameStatQuery>   EndConditions                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMinigameSettingsMachine_C::TryAddEndCondition_CollectItems(TArray<struct FFortMinigameStatQuery>& EndConditions, bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "TryAddEndCondition_CollectItems");

	Params::MinigameSettingsMachine_C_TryAddEndCondition_CollectItems Parms{};

	Parms.EndConditions = std::move(EndConditions);

	UObject::ProcessEvent(Func, &Parms);

	EndConditions = std::move(Parms.EndConditions);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateAutoStart
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateAutoStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateAutoStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateEndConditions
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateEndConditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateEndConditions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateTeamToMoveToWhenOutOfSpawns
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateTeamToMoveToWhenOutOfSpawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateTeamToMoveToWhenOutOfSpawns");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateAutoEndTeamThreshold
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateAutoEndTeamThreshold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateAutoEndTeamThreshold");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdatePlayerLives
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdatePlayerLives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdatePlayerLives");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdatePostGameSpawnLocationSetting
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdatePostGameSpawnLocationSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdatePostGameSpawnLocationSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateTeamSetting
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateTeamSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateTeamSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateSpawnLocationSetting
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateSpawnLocationSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateSpawnLocationSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.GetCurrentMinigame
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AFortMinigame*                    Minigame                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::GetCurrentMinigame(class AFortMinigame** Minigame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "GetCurrentMinigame");

	Params::MinigameSettingsMachine_C_GetCurrentMinigame Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Minigame != nullptr)
		*Minigame = Parms.Minigame;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateTimeLimit
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateTimeLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateTimeLimit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateGameMode
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateGameMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.HasMinigameStarted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    bHasStarted                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMinigameSettingsMachine_C::HasMinigameStarted(bool* bHasStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "HasMinigameStarted");

	Params::MinigameSettingsMachine_C_HasMinigameStarted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bHasStarted != nullptr)
		*bHasStarted = Parms.bHasStarted;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.GetPickupSpawnLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          SpawnLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::GetPickupSpawnLocation(struct FVector* SpawnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "GetPickupSpawnLocation");

	Params::MinigameSettingsMachine_C_GetPickupSpawnLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnLocation != nullptr)
		*SpawnLocation = std::move(Parms.SpawnLocation);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.OnComplete_C895978B4EDC5073967F23BED63E6DB5
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      UserWidget                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::OnComplete_C895978B4EDC5073967F23BED63E6DB5(class UUserWidget* UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "OnComplete_C895978B4EDC5073967F23BED63E6DB5");

	Params::MinigameSettingsMachine_C_OnComplete_C895978B4EDC5073967F23BED63E6DB5 Parms{};

	Parms.UserWidget = UserWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AMinigameSettingsMachine_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.OnGameSettingsUpdated
// (BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::OnGameSettingsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "OnGameSettingsUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.StartMinigameHelper
// (BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::StartMinigameHelper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "StartMinigameHelper");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.AbandonMinigameHelper
// (BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::AbandonMinigameHelper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "AbandonMinigameHelper");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.ShowSolaris
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::ShowSolaris()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "ShowSolaris");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UseSolaris
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShouldUse                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMinigameSettingsMachine_C::UseSolaris(bool bShouldUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UseSolaris");

	Params::MinigameSettingsMachine_C_UseSolaris Parms{};

	Parms.bShouldUse = bShouldUse;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.ExecuteUbergraph_MinigameSettingsMachine
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::ExecuteUbergraph_MinigameSettingsMachine(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "ExecuteUbergraph_MinigameSettingsMachine");

	Params::MinigameSettingsMachine_C_ExecuteUbergraph_MinigameSettingsMachine Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.BlueprintGetFailedInteractionString
// (HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class AFortPawn*                        InteractingPawn                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText AMinigameSettingsMachine_C::BlueprintGetFailedInteractionString(const class AFortPawn* InteractingPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "BlueprintGetFailedInteractionString");

	Params::MinigameSettingsMachine_C_BlueprintGetFailedInteractionString Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.BlueprintGetInteractionString
// (HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class AFortPawn*                        InteractingPawn                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText AMinigameSettingsMachine_C::BlueprintGetInteractionString(const class AFortPawn* InteractingPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "BlueprintGetInteractionString");

	Params::MinigameSettingsMachine_C_BlueprintGetInteractionString Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.BlueprintCanInteract
// (HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AFortPawn*                        InteractingPawn                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AMinigameSettingsMachine_C::BlueprintCanInteract(const class AFortPawn* InteractingPawn) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "BlueprintCanInteract");

	Params::MinigameSettingsMachine_C_BlueprintCanInteract Parms{};

	Parms.InteractingPawn = InteractingPawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

